# üòÅ Awesome DCIST T4 üòÅ

<div align="center">
  A curated collection of resources focused on the MIT DCIST ü™ñ stack and related technologies.

  [**Browse the CRA**](https://arl.devcom.army.mil/cras/dcist-cra/) | [**Contribute**](CONTRIBUTING.md)
</div>


## Contents

- [Installation](#installation)
- [Documentation](#documentation)
- [Tools & Utilities](#tools-utilities)
- [Sponsors](#sponsors)


## Installation

Install dependencies:
```bash
sudo apt install pipx python3-virtualenv python3-colcon-clean
pipx install -f tmuxp pre-commit
echo 'export PATH=$PATH:$HOME/.local/bin' >> ~/.zshrc
```

*(Optional)* Set up semantic inference dependencies [here](https://github.com/MIT-SPARK/semantic_inference/blob/ros2/docs/closed_set.md#getting-dependencies)

Set up the workspace:
```bash
# Feel free to change the workspace
mkdir -p ~/colcon_ws/src && cd ~/colcon_ws
git clone git@github.com:MIT-SPARK/Awesome-DCIST-T4.git src/awesome_dcist_t4 --recursive
vcs import src < src/awesome_dcist_t4/install/packages.yaml
rosdep install --from-paths src --ignore-src -r -y # Make sure you have sourced ROS!!!
echo export ADT4_WS=`pwd` >> ~/.zshrc

# Feel free to change the environment directory path
echo export ADT4_ENV=$(realpath ~/environments/dcist) >> ~/.zshrc

# This will create all necessary python environments to run DCIST code
source $ADT4_WS/src/awesome_dcist_t4/install/python_setup.sh
```

Build:
```bash
# this next step is CRUCIAL to get colcon to behave properly
pushd $DCIST_WS
# this will error most likely but it's fine...
colcon build --continue-on-error --symlink-install
popd
```

## Python environments

For the time being, we are assuming different modules can run with different python environments,
although in the coming months we may want to use a single python environment.
These environments should be created in the directory `$DCIST_ENV` by the `install/python_setup.sh` script.

To run different modules with different environments, it is important that the ROS packages are built **without** `--symlink-install`.

## Running
If you want to see hydra running on real Spot data, get the bag from Aaron (and
convert by `pipx install rosbags; rosbags-convert --src
spot_hydra_twocam_test.bag --dst spot_hydra_twocam_test`).


You should be able to load a tmuxp launch file by navigating to
`awesome-dcist-t4/dcist_launch_system/tmux` and running

```bash
tmuxp load dcist_launch.yaml
```

To see Hydra running:
```
ros2 bag play /path/to/spot_hydra_twocam_test --clock --qos-overrides-path ~/tf_overrides.yaml
```
where `~/tf_overrides.yaml` looks like
```yaml
/tf_static: {depth: 1, durability: transient_local}
```

## Example System Configurations

### Hydra with Bag

Make sure you have an override file for the tf qos, e.g., `~/tf_overrides.yaml`
looks like

```yaml
/tf_static: {depth: 1, durability: transient_local}
```

Then run `tmuxp load
dcist_launch_system/tmux/autogenerated/spot_bag-spot_odom-bag.yaml`. In a
separate window, run the bag

```
ros2 bag play /path/to/spot_hydra_twocam_test --clock --qos-overrides-path ~/tf_overrides.yaml
```

### Prior Scene Graph and Movable Spot

Alternatively, you can drive spot around (and plan in?) a prior scene graph.
First you need to set the path to the prior scene graph in the environment
variable `ADT4_PRIOR_DSG_PATH` to the absolute path to your prior graph.

Then run
```
tmuxp load dcist_launch_system/tmux/autogenerated/spot_prior_dsg-spot_odom-spot_prior_dsg.yaml
```



## Documentation
Haha

## Tools & Utilities

## Configuring Parameters

This section will give some technical explanation about how parameters are
managed in ADT4. The following section builds on this and explains the full
power of the `experiment_manifest.yaml` file that allows composing overrides
and generating tmux launch files.

All ROS nodes in `ADT4` load their config from
`dcist_launch_system/config/<experiment_key>/<node_name>.yaml`. The yaml files
under the `<experiment_key>` directory have a full set of the yaml parameters
that are necessary to run the stack. However, most parameters are the same
between different configurations, usually requiring only a small number of
parameters to be changed from different robot or autonomy configurations.

To make it possible to keep track of which parameters can be shared between
configurations vs. which are system-specific, the system-specific
configurations are automatically generated from files that explicitly factorize
which parameters should be different for a given configuration.

In `dcist_launch_system/config_generation/base_params`, we store a full set of
*all* the parameters. Then, in
`dcist_launch_system/config_generation/experiment_overrides/<experiment_key>` we
have override files that specify specific parameters that should be overridden
for a given configuration. We use `ytt` to do this yaml templating. For
    example, consider `base_params/spot_executor_node.yaml`:

```
/**:
    ros__parameters:
        odom_frame: "map"
        body_frame: "body"
        use_fake_spot_pose: false
        fake_spot_external_pose: true
        spot_ip: "10.0.0.3"
        bosdyn_client_username: "$(env BOSDYN_CLIENT_USERNAME)"
        bosdyn_client_password: "$(env BOSDYN_CLIENT_PASSWORD)"
        .....
```

`use_fake_spot_pose` and `fake_external_pose` need to be changed depending on
whether we are running from a bag that provides a pose for spot, or a
"simulated" spot where spot controls its own pose. In
`config_generation/experiment_overrides/spot_prior_dsg/spot_executor_node_overlay.yaml`
we specify that for the `spot_prior_dsg` parameter setting, these two flags should be
flipped:

```
#@ load("@ytt:overlay", "overlay")

#@overlay/match by=overlay.all, expects="1+"
---
/**:
    ros__parameters:
        use_fake_spot_pose: true
        fake_spot_external_pose: false

```

The naming of this file is important -- our compositor will update a `<node
name>.yaml` base param file by searching for `<node name>_overlay.yaml` file.
When you need to make a new overlay, just copy the boilerplate at the top.

This specifies the values that should be used in the `base_params` file. To generate the actual configuration, you need to install `ytt` (https://carvel.dev/ytt/),

```
wget -O- https://carvel.dev/install.sh > install.sh
## NOTE: running the install script installs a couple of kubernetes-related utilities in addition to ytt.
## If you don't want that, you can remove those lines in the install.sh before running the command below.
sudo bash install.sh
ytt version
```

To do the generation, run `generate_configs.py`, which can be found in
`config_generation`. `generate_configs.py` takes three arguments -- a root
directory for the parameter specifications live (i.e.,
`dcist_launch_system/config_generation`), the directory where you want to output config files (normally `dcist_launch_system/config`) and where to output the generated tmux launch files (normally `dcist_launch_system/tmux/autogenerated`). There is also a verbose and quiet flag.

So, a normal invocation will look like:
```bash
cd dcist_launch_system/config_generation
./generate_configs.py . ../config ../tmux/autogenerated
```

## Config Generation "Experiment Manifest"

The config generation process is controlled by a file called
`experiment_manifest.yaml` found in the root directory that
`generate_configs.py` is invoked with (e.g.,
`dcist_launch_system/config_generation/experiment_manifest.yaml`. There are
three parts of this file -- `launch_configs`, `parameter_groupings`, and
`experiments`.

The launch configs allow you to build up a tmuxp file composed of reusable
windows. Each item under launch configs is a name for a group of windows. A
name with no children is a "window primitive", and a yaml file with the same
name should be present in `config_generation/launch_components`. Note that the
launch specification is composable, in the sense that the children of a launch
config don't need to be primitives.

The parameter groupings follow a similar compositional logic. A parameter
grouping with no children should be a directory under `experiment_overrides`. A
parameter grouping that does have children will apply all descendant primitive
configs as overrides.

Finally, the experiments section generates launch files for the specified
combination of launch config X parameter grouping X {other variables}. The
syntax and semantics of these {other variables} is going to change soon, but
roughly they map to environment variables that are set in the tmux file.


## Sponsors

A big thank you to our sponsors for their generous support:

* [ARL Distributed and Collaborative Intelligent Systems and Technology Collaborative Research Alliance (DCIST
CRA) agreement W911NF-17-2-0181](https://arl.devcom.army.mil/cras/dcist-cra/)
