# üòÅ Awesome DCIST T4 üòÅ

<div align="center">
  A curated collection of resources focused on the MIT DCIST ü™ñ stack and related technologies.

  [**Browse the CRA**](https://arl.devcom.army.mil/cras/dcist-cra/) | [**Contribute**](CONTRIBUTING.md)
</div>


## Contents

- [Installation](#installation)
- [Documentation](#documentation)
- [Tools & Utilities](#tools-utilities)
- [Sponsors](#sponsors)


## Installation

Install dependencies:
```bash
sudo apt install pipx python3-virtualenv python3-colcon-clean
pipx install -f tmuxp
pipx install -f pre-commit
echo 'export PATH=$PATH:$HOME/.local/bin' >> ~/.zshrc
```

*(Optional)* Set up semantic inference dependencies [here](https://github.com/MIT-SPARK/semantic_inference/blob/ros2/docs/closed_set.md#getting-dependencies)

Set up the workspace:
```bash
# Feel free to change the workspace
mkdir -p ~/colcon_ws/src && cd ~/colcon_ws
git clone git@github.com:MIT-SPARK/Awesome-DCIST-T4.git src/awesome_dcist_t4 --recursive
vcs import src < src/awesome_dcist_t4/install/packages.yaml
rosdep install --from-paths src --ignore-src -r -y # Make sure you have sourced ROS!!!
echo export ADT4_WS=`pwd` >> ~/.zshrc

# Feel free to change the environment directory path
echo export ADT4_ENV=$(realpath ~/environments/dcist) >> ~/.zshrc

# Feel free to change the output directory (saved scene graphs, logs, etc)
echo export ADT4_OUTPUT_DIR=$(realpath ~/adt4_output) >> ~/.zshrc

# This will create all necessary python environments to run DCIST code
source $ADT4_WS/src/awesome_dcist_t4/install/python_setup.sh

# You also need to set the spot username/password. These can be empty if you are simulating spot
echo export ADT4_BOSDYN_USERNAME="" >> ~/.zshrc
echo export ADT4_BOSDYN_PASSWORD="" >> ~/.zshrc

# You also need to set the robot name. Example:
echo export ADT4_ROBOT_NAME="spot" >> ~/.zshrc

```

Build:
```bash
# this next step is CRUCIAL to get colcon to behave properly
pushd $ADT4_WS
# this will error most likely but it's fine...
colcon build --continue-on-error
popd
```

### Environment Variable Summary

| Environment Variable Name         | Description                           |
|-----------------------------------|---------------------------------------|
| ADT4\_WS                          | Colcon workspace root                 |
| ADT4\_ENV                         | Directory of Python venvs             |
| ADT4\_OUTPUT\_DIR                 | Output directory (logs, data, etc)    |
| ADT4\_BOSDYN\_USERNAME            | Spot username                         |
| ADT4\_BOSDYN\_PASSWORD            | Spot password                         |
| ADT4\_BOSDYN\_IP                  | Spot IP (e.g, 192.168.80.3 for wifi)  |
| ADT4\_PRIOR\_DSG\_PATH            | Prior scene graph for planning        |
| ADT4\_ROBOT\_NAME                 | Robot name (e.g. "spot")              |

## Python environments

For the time being, we are assuming different modules can run with different
python environments, although in the coming months we may want to use a single
python environment.  These environments should be created in the directory
`$ADT4_ENV` by the `install/python_setup.sh` script.

To run different modules with different environments, it is important that the
ROS packages are built **without** `--symlink-install`.

### !!! Important !!!
Finally, the `spark_dsg` package needs to build python bindings every time it
is updated. This means that you need to manually pip install `spark_dsg`!
Please run
```
source $ADT_ENV/spark_env/bin/activate
pip install $ADT4_WS/src/awesome_dcist_t4/spark_dsg
```
now and any time `spark_dsg` updates.


## Example System Configurations

### Hydra with Bag

If you want to see hydra running on real Spot data, get the bag from Aaron (and
convert by `pipx install rosbags; rosbags-convert --src
spot_hydra_twocam_test.bag --dst spot_hydra_twocam_test`).

Make sure you have an override file for the tf qos, e.g., `~/tf_overrides.yaml`
looks like

```yaml
/tf_static: {depth: 1, durability: transient_local}
```

Then run
```
tmuxp load dcist_launch_system/tmux/autogenerated/spot_bag-bag-sim_time.yaml
```

In a separate window, run the bag

```
ros2 bag play /path/to/spot_hydra_twocam_test --clock --qos-overrides-path ~/tf_overrides.yaml
```

### Prior Scene Graph and Movable Spot

Alternatively, you can drive spot around (and plan in?) a prior scene graph.
First you need to set the path to the prior scene graph in the environment
variable `ADT4_PRIOR_DSG_PATH` to the absolute path to your prior graph.

Then run
```
tmuxp load dcist_launch_system/tmux/autogenerated/spot_prior_dsg-spot_prior_dsg-no_sim_time.yaml
```

There will be controls for moving spot around in one of the windows. You can
send spot a plan with:

```
ros2 topic pub /omniplanner_node/language_planner/language_goal omniplanner_msgs/msg/LanguageGoalMsg "{robot_id: 'spot', command: 'R(70) R(23)'}" -1
```

This should result in a planned path appearing in RVIZ, and spot following the
plan.

### Catalog of Supported Launch Configurations

| Tmux Launch Name                                     | Description                                                                |
|------------------------------------------------------|--------------------------------------------------------------------------  |
| spot\_bag-bag-sim\_time.yaml                         | Runs with single spot robot, based on a bag, using sim time.               |
| spot\_prior\_dsg-spot\_prior\_dsg-no\_sim\_time.yaml | Runs with a single spot robot and a prior scene graph, deployable on-robot |
| spot\_prior\_dsg-spot\_prior\_dsg-sim\_time.yaml     | Runs with a single spot robot and a prior scene graph with sim time.       |



## Tools & Utilities

### Saving a Scene Graph

Most of the launch configurations launch a scene graph saver node. You can save
a scene graph from the commandline by running

```
ros2 service call /dsg_saver/save_dsg dcist_launch_system_msgs/srv/SaveDsg "{save_path: '', include_mesh: true}"
```
If you leave `save_path`, it will default to saving under `$ADT4_OUTPUT_DIR`

## Configuring Parameters

This section will give some technical explanation about how parameters are
managed in ADT4. The following section builds on this and explains the full
power of the `experiment_manifest.yaml` file that allows composing overrides
and generating tmux launch files.

All ROS nodes in `ADT4` load their config from
`dcist_launch_system/config/<experiment_key>/<node_name>.yaml`. The yaml files
under the `<experiment_key>` directory have a full set of the yaml parameters
that are necessary to run the stack. However, most parameters are the same
between different configurations, usually requiring only a small number of
parameters to be changed from different robot or autonomy configurations.

To make it possible to keep track of which parameters can be shared between
configurations vs. which are system-specific, the system-specific
configurations are automatically generated from files that explicitly factorize
which parameters should be different for a given configuration.

In `dcist_launch_system/config_generation/base_params`, we store a full set of
*all* the parameters. Then, in
`dcist_launch_system/config_generation/experiment_overrides/<experiment_key>`
we have override files that specify specific parameters that should be
overridden for a given configuration. We use `ytt` to do this yaml templating.
For example, consider `base_params/spot_executor_node.yaml`:

```
/**:
    ros__parameters:
        odom_frame: "map"
        body_frame: "body"
        use_fake_spot_pose: false
        fake_spot_external_pose: true
        spot_ip: "10.0.0.3"
        bosdyn_client_username: "$(env BOSDYN_CLIENT_USERNAME)"
        bosdyn_client_password: "$(env BOSDYN_CLIENT_PASSWORD)"
        .....
```

`use_fake_spot_pose` and `fake_external_pose` need to be changed depending on
whether we are running from a bag that provides a pose for spot, or a
"simulated" spot where spot controls its own pose. In
`config_generation/experiment_overrides/spot_prior_dsg/spot_executor_node_overlay.yaml`
we specify that for the `spot_prior_dsg` parameter setting, these two flags should be
flipped:

```
#@ load("@ytt:overlay", "overlay")

#@overlay/match by=overlay.all, expects="1+"
---
/**:
    ros__parameters:
        use_fake_spot_pose: true
        fake_spot_external_pose: false

```

The naming of this file is important -- our compositor will update a `<node
name>.yaml` base param file by searching for `<node name>_overlay.yaml` file.
When you need to make a new overlay, just copy the boilerplate at the top.

This specifies the values that should be used in the `base_params` file. To generate the actual configuration, you need to install `ytt` (https://carvel.dev/ytt/),

```
wget -O- https://carvel.dev/install.sh > install.sh
## NOTE: running the install script installs a couple of kubernetes-related utilities in addition to ytt.
## If you don't want that, you can remove those lines in the install.sh before running the command below.
sudo bash install.sh
ytt version
```

To do the generation, run `generate_configs.py`, which can be found in
`config_generation`. `generate_configs.py` takes three arguments -- a root
directory for the parameter specifications live (i.e.,
`dcist_launch_system/config_generation`), the directory where you want to
output config files (normally `dcist_launch_system/config`) and where to output
the generated tmux launch files (normally
`dcist_launch_system/tmux/autogenerated`). There is also a verbose and quiet
flag.

There is a script that has the correct input/output directories filled in, so
you should normally be able to run
`dcist_launch_system/scripts/generate_configs.sh`. But you can also run the
python script directly to control input/output directories, e.g.,:

```bash
cd dcist_launch_system/config_generation
./generate_configs.py . ../config ../tmux/autogenerated
```

## Config Generation "Experiment Manifest"

The config generation process is controlled by a file called
`experiment_manifest.yaml` found in the root directory that
`generate_configs.py` is invoked with (e.g.,
`dcist_launch_system/config_generation/experiment_manifest.yaml`. There are
three parts of this file -- `launch_configs`, `configs`, and `experiments`.

The `launch_configs` allow you to build up a tmuxp file composed of reusable
windows. Each item under launch configs is a name for a group of windows. A
name with no children is a "window primitive", and a yaml file with the same
name should be present in `config_generation/launch_components`. Note that the
launch specification is composable, in the sense that the children of a launch
config don't need to be primitives.

The `configs` follow a similar compositional logic. A config with no children
should be a directory under `experiment_overrides`. A parameter grouping that
does have children will apply all descendant primitive configs as overrides.

Finally, the `experiments` section generates launch files for the specified
combination of launch config X parameter grouping X {other variables}. The
syntax and semantics of these {other variables} is going to change soon, but
roughly they map to environment variables that are set in the tmux file.


## Sponsors

A big thank you to our sponsors for their generous support:

* [ARL Distributed and Collaborative Intelligent Systems and Technology Collaborative Research Alliance (DCIST
CRA) agreement W911NF-17-2-0181](https://arl.devcom.army.mil/cras/dcist-cra/)
