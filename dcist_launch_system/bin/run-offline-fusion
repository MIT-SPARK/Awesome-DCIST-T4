#!/usr/bin/env python3
"""Parse robot files and add to single json file."""

import copy
import json
import pathlib
import shutil
import sys
from typing import List
import numpy as np
import yaml
import subprocess

import click
from roman.align.submap_align import submap_align
from roman.params.submap_align_params import SubmapAlignInputOutput, SubmapAlignParams
from roman.offline_rpgo.densify_optimized_sparse_trajectory import densify_optimized_sparse_trajectory
from roman.params.data_params import DataParams, ImgDataParams, PoseDataParams
from roman.map.offline_map_runner import mapping as offline_roman_mapping
import robotdatapy as rdp


def _info(msg):
    click.secho(f"[INFO] {msg}", fg="green")


def _warn(msg):
    click.secho(f"[WARNING] {msg}", fg="yellow")


def _error(msg):
    click.secho(f"[ERROR] {msg}", fg="red")


def _normalize_path(path):
    return pathlib.Path(path).expanduser().absolute()


def _resolve_output(output, force, clean):
    output = _normalize_path("fused") if output is None else _normalize_path(output)
    _info(f"Writing results to {output}!")
    if output.exists():
        if clean:
            if not force:
                click.confirm(f"clean existing {output}?", abort=True, default=False)

            shutil.rmtree(output)

    output.mkdir(parents=True, exist_ok=True)
    return output


def _hydra_multi_config(config):
    pkg_path = pathlib.Path(__file__).absolute().parent.parent
    config_path = pkg_path / "config" / config / "offline_fusion.yaml"
    if not config_path.exists():
        _error(f"Invalid Hydra-Multi config: {config_path}")
        sys.exit("Invalid config")

    _info(f"Using Hydra-Multi config: {config_path}")
    return config_path


def _roman_config(config):
    pkg_path = pathlib.Path(__file__).absolute().parent.parent
    config_path = pkg_path / "config" / config / "roman_lc.yaml"
    if not config_path.exists():
        _error(f"Invalid ROMAN config: {config_path}")
        sys.exit("Invalid config")

    _info(f"Using ROMAN config: {config_path}")
    return SubmapAlignParams.from_yaml(str(config_path))

def _fastsam_config(config):
    pkg_path = pathlib.Path(__file__).absolute().parent.parent
    config_path = pkg_path / "config" / config / "fastsam.yaml"
    if not config_path.exists():
        _error(f"Invalid FastSAM config: {config_path}")
        sys.exit("Invalid config")
    _info(f"Using FastSAM config: {config_path}")
    return config_path

def _roman_map_config(config):
    pkg_path = pathlib.Path(__file__).absolute().parent.parent
    config_path = pkg_path / "config" / config / "roman_map.yaml"
    if not config_path.exists():
        _error(f"Invalid ROMAN Map config: {config_path}")
        sys.exit("Invalid config")
    _info(f"Using ROMAN Map config: {config_path}")
    return config_path

def _convert_time(contents, idx):
    stamp_ns = int(contents["seconds"][idx] * 1.0e9)
    return stamp_ns + int(contents["nanoseconds"][idx])


def _convert_rot(contents):
    return {k: v for k, v in zip(contents["rotation_convention"], contents["rotation"])}


def lcd(config: SubmapAlignParams, robots: List[pathlib.Path], output: pathlib.Path):
    """Run and collate loop closures between robots."""
    lcd_output = output / "lcd"
    lcd_output.mkdir(exist_ok=True)

    out_path = output / "loop_closures.json"
    if out_path.exists():
        _info("LCD output exists! skipping")
        return out_path

    # iterate through every pair of robots
    loop_closures = []
    for i in range(len(robots)):
        for j in range(i, len(robots)):
            name = f"{robots[i].name}_{robots[j].name}"
            order = [robots[i].name, robots[j].name]
            input_files = [
                robots[i] / "roman" / "roman_map.pkl",
                robots[j] / "roman" / "roman_map.pkl",
            ]
            sm_io = SubmapAlignInputOutput(
                inputs=[str(x) for x in input_files],
                output_dir=str(lcd_output),
                run_name=name,
                robot_names=order,
            )

            config = copy.deepcopy(config)
            config.single_robot_lc = i == j
            submap_align(sm_params=config, sm_io=sm_io)
            with open(sm_io.output_lc_json, "r") as fin:
                contents = json.load(fin)
                _info(f"Loaded {len(contents)} loop closures for {i} -> {j}")
                for x in contents:
                    # convention is names[1]_T_names[0]
                    # NOTE(nathan) we want to force the robot IDs to be 1-indexed
                    loop_closures.append(
                        {
                            "robot_from": order.index(x["names"][1]) + 1,
                            "time_from": _convert_time(x, 1),
                            "robot_to": order.index(x["names"][0]) + 1,
                            "time_to": _convert_time(x, 0),
                            "to_p_from": x["translation"],
                            "to_R_from": _convert_rot(x),
                        }
                    )

    with out_path.open("w") as fout:
        json.dump(loop_closures, fout, indent=2)

    _info(f"Wrote {len(loop_closures)} loop closures to {out_path}!")
    return out_path

def densify(adt4_output_directories: List[pathlib.Path], 
            names: List[pathlib.Path], 
            optimized_trajectories: List[pathlib.Path],
            output_dir: pathlib.Path):
    """Densify optimized trajectories using odometry data."""
    for i in range(len(adt4_output_directories)):
        optimized_pose_data = rdp.data.PoseData.from_kmd_gt_csv(
            optimized_trajectories[i], time_tol=100.0)
        bag = adt4_output_directories[i] / "bag"
        try:
            odometry_pose_data = rdp.data.PoseData.from_bag_tf(
                str(bag), f"{names[i]}/odom", f"{names[i]}/base_link", time_tol=10.0)
        except Exception as e:
            odometry_pose_data = rdp.data.PoseData.from_bag_tf(
                str(bag), f"{names[i]}/odom", f"{names[i]}/body", time_tol=10.0)
        
        densified_optimized_trajectory = densify_optimized_sparse_trajectory(
            dense_unoptimized=odometry_pose_data,
            sparse_optimized=optimized_pose_data)
        
        densified_optimized_trajectory.to_csv(str(
            output_dir / f"{adt4_output_directories[i].name}.csv"))
        
def rerun_roman(adt4_output_directories: List[pathlib.Path], 
                names: List[pathlib.Path], 
                dense_optimized_trajectories: List[pathlib.Path],
                output_dir: pathlib.Path,
                fastsam_params_path: str,
                roman_map_params_path: str
                ):
    """Rerun ROMAN with densified trajectories."""
    

    for i in range(len(adt4_output_directories)):
        try:
            T_base_camera = rdp.PoseData.any_static_tf_from_bag(
                str(adt4_output_directories[i] / "bag"),
                f"{names[i]}/base_link",
                f"{names[i]}_zed_left_camera_optical_frame",
            )
        except Exception as e:
            T_base_camera = rdp.PoseData.any_static_tf_from_bag(
                str(adt4_output_directories[i] / "bag"),
                f"{names[i]}/body",
                f"{names[i]}_zed_left_camera_optical_frame",
            )
        data_params_dict = {
            'dt': 1/6,
            'runs': [adt4_output_directories[i].name],
            'img_data': {
                'path': str(adt4_output_directories[i] / "bag"),
                'topic': f"/{names[i]}/{names[i]}_zed/rgb/image_rect_color",
                'camera_info_topic': f"/{names[i]}/{names[i]}_zed/rgb/camera_info",
                'compressed': False,
                'color_space': 'bgr8',
            },
            'depth_data': {
                'path': str(adt4_output_directories[i] / "bag"),
                'topic': f"/{names[i]}/{names[i]}_zed/depth/depth_registered",
                'camera_info_topic': f"/{names[i]}/{names[i]}_zed/depth/camera_info",
                'compressed': False,
            },
            'pose_data': {
                'type': 'csv',
                'path': str(dense_optimized_trajectories[i]),
                'csv_options': rdp.data.pose_data.KMD_GT_CSV_OPTIONS,
                'time_tol': 10.0,
                'T_camera_flu': {
                    'input_type': 'matrix',
                    'matrix': np.linalg.inv(T_base_camera).flatten().tolist()
                },
                'T_odombase_camera': {
                    'input_type': 'matrix',
                    'matrix': T_base_camera.flatten().tolist()
                }
            }
        }
        
        run_output_dir = output_dir / adt4_output_directories[i].name
        run_output_dir.mkdir(exist_ok=True)
        run_params_dir = run_output_dir / "params"
        run_params_dir.mkdir(exist_ok=True)
        with open(run_params_dir / "data.yaml", 'w') as f:
            yaml.dump(data_params_dict, f)
        subprocess.run(['cp', fastsam_params_path, str(run_params_dir / "fastsam.yaml")])
        subprocess.run(['cp', roman_map_params_path, str(run_params_dir / "mapper.yaml")])
        
        offline_roman_mapping(
            params_path=str(run_params_dir),
            output_path=str(run_output_dir / 'roman_map'),
            run_name=adt4_output_directories[i].name,
            max_time=600.0, # otherwise RAM usage gets too high
        )
        
        # will produce a file: roman / <run name> / roman_map.pkl 

@click.command()
@click.argument("output", type=click.Path())
@click.argument("robot_directories", nargs=-1, type=click.Path(exists=True))
@click.option("-f", "--force", is_flag=True, help="proceed without prompting")
@click.option("-v", "--verbosity", type=int, default=0, help="glog verbosity")
@click.option("-c", "--config", default="default_params", help="config to use")
@click.option("--rerun", is_flag=True, help="remove previous output if it exists")
@click.option("--gnc-alpha", default=None, type=float, help="gnc alpha to use")
def main(
    output,
    robot_directories,
    force,
    verbosity,
    config,
    rerun,
    gnc_alpha,
):
    """
    Detect loop closures between robots and fuse scene graphs.

    Arguments:
        OUTPUT: directory to save results
        ROBOT_DIRECTORIES: input directories for the robots
    """
    output = _resolve_output(output, force, rerun)
    robot_directories = [_normalize_path(x) for x in robot_directories]
    robot_order = [x.stem for x in robot_directories]
    _info(f"Robot order: {robot_order}")

    hydra_multi_config = _hydra_multi_config(config)
    roman_config = _roman_config(config)
    fastsam_config = _fastsam_config(config)
    roman_map_config = _roman_map_config(config)
    lcd_file = lcd(roman_config, robot_directories, output)

    command = [
        "offline_fusion",
        "--config",
        str(hydra_multi_config),
        f"-v={verbosity}",
        "--output",
        str(output),
        "--loopclosures",
        str(lcd_file),
    ] + [str(_normalize_path(x)) for x in robot_directories]
    if gnc_alpha is not None:
        command += ["--gnc_alpha", str(gnc_alpha)]

    _info(f"cmd: {' '.join(command)}")


    #     ret = subprocess.run(command)
    # if ret.returncode != 0:
    # _error("Fusion failed!")
    
    (output / "roman").mkdir(exist_ok=True)
    densify(
        adt4_output_directories=robot_directories,
        # names=names, # TODO: need to fix this to handle different robot names
        names=None,
        optimized_trajectories=[output / f"{x.stem}.csv" for x in robot_directories],
        output_dir=output / "roman"
    )
    rerun_roman(
        adt4_output_directories=robot_directories,
        # names=names, # TODO: need to fix this to handle different robot names
        names=None,
        dense_optimized_trajectories=[output / "roman" / f"{x.stem}.csv" for x in robot_directories],
        output_dir=output / "roman",
        fastsam_params_path=str(fastsam_config),
        roman_map_params_path=str(roman_map_config)
    )


if __name__ == "__main__":
    main()
