#!/usr/bin/env python3
"""Parse robot files and add to single json file."""

import bisect
import copy
import json
import pathlib
import shutil
import subprocess
from dataclasses import dataclass, field
from typing import List

import click
import numpy as np
import scipy.spatial.transform as sprot
import spark_dsg as dsg
from roman.align.params import SubmapAlignInputOutput, SubmapAlignParams
from roman.align.submap_align import submap_align


def _normalize_path(path):
    return pathlib.Path(path).expanduser().absolute()


def _convert_time(contents, idx):
    stamp_ns = int(contents["seconds"][idx] * 1.0e9)
    return stamp_ns + int(contents["nanoseconds"][idx])


def _convert_rot(quaternion_record, order):
    return {k: v for k, v in zip(order, quaternion_record)}


def _get_index(order, name):
    return order.index(name)


def _default_config():
    pkg_path = pathlib.Path(__file__).absolute().parent.parent
    config_path = pkg_path / "config" / "perception" / "hydra_multi" / "offline.yaml"
    return config_path


def _convert_file(contents, order, body_frame):
    loop_closures = []
    for x in contents:
        # convention is names[1]_T_names[0]
        to_R_from = _convert_rot(x["rotation"], x["rotation_convention"])
        to_p_from = x["translation"]
        robot_from = x["names"][1]
        robot_to = x["names"][0]
        loop_closures.append(
            {
                "robot_from": _get_index(order, robot_from),
                "time_from": _convert_time(x, 1),
                "robot_to": _get_index(order, robot_to),
                "time_to": _convert_time(x, 0),
                "to_p_from": to_p_from,
                "to_R_from": to_R_from,
                "in_body_frame": body_frame,
            }
        )

    return loop_closures


def lcd(
    robot_directories: List[pathlib.Path],
    root_output_dir: pathlib.Path,
    submap_max_size: int = 40,
    lc_association_thresh: int = 4,
):
    """
    Create loop closures files.

    Path directory will be:
    root_output_dir:
    - lcd/
      - robot0_robot0.json
      - robot0_robot1.json
      ...
      - robot0.sm.json
      - robot1.sm.json
      ...
    """
    lcd_output_dir = root_output_dir / "lcd"
    if lcd_output_dir.exists():
        click.secho("LCD output exists! skipping", fg="yellow")
        return

    lcd_output_dir.mkdir(exist_ok=True)

    # iterate through every pair of robots
    for i in range(len(robot_directories)):
        for j in range(i, len(robot_directories)):
            input_files = [
                str(robot_directories[i] / "roman_map.pkl"),
                str(robot_directories[j] / "roman_map.pkl"),
            ]
            sm_io = SubmapAlignInputOutput(
                inputs=input_files,
                output_dir=str(lcd_output_dir),
                run_name=f"{robot_directories[i].name}_{robot_directories[j].name}",
                robot_names=[robot_directories[i].name, robot_directories[j].name],
                # lc_association_thresh=4,
            )
            sm_params = SubmapAlignParams()
            sm_params.method = "pcavolgrav"
            sm_params.submap_max_size = submap_max_size
            sm_params.single_robot_lc = i == j
            sm_params.force_rm_upside_down = True
            sm_params.use_object_bottom_middle = True
            sm_io.lc_association_thresh = lc_association_thresh

            # run loop closure detection
            submap_align(sm_params=sm_params, sm_io=sm_io)


def collate_loopclosures(output, order, remaps, body_frame):
    """Load and convert robot loop closures."""
    loop_closures_path = output / "lcd"
    loop_closures = [x for x in loop_closures_path.glob("*.json")]
    loop_closures = [x for x in loop_closures if ".sm.json" not in x.name]

    roman_order = [remaps.get(x, x) for x in order]
    all_loopclosures = []
    for lcd_file in loop_closures:
        with lcd_file.open("r") as fin:
            contents = json.load(fin)

        click.secho(f"Loaded {len(contents)} loop closures from {lcd_file}", fg="green")
        all_loopclosures += _convert_file(contents, roman_order, body_frame)

    out_path = output / "loop_closures.json"
    click.secho(
        f"Writing {len(all_loopclosures)} loop closures to {out_path}!", fg="green"
    )
    with out_path.open("w") as fout:
        json.dump(all_loopclosures, fout, indent=2)

    return out_path


def _save_map(map_path, order, output):
    map_path = _normalize_path(map_path)
    with map_path.open("r") as fin:
        contents = json.load(fin)

    robot_name = map_path.stem.split(".")[0]  # drops the .sm
    info = {}
    info["robot_id"] = _get_index(order, robot_name)
    info["points"] = []

    for segment in contents["segments"]:
        stamp_info = segment["last_seen"]
        stamp_ns = int(stamp_info["seconds"] * 1.0e9) + int(stamp_info["nanoseconds"])
        info["points"].append(
            {"pos": segment["centroid_odom"], "timestamp_ns": stamp_ns}
        )

    point_path = output / map_path.name
    with point_path.open("w") as fout:
        json.dump(info, fout)

    return point_path


@dataclass
class Pose:
    """Class for holding pose information."""

    rotation: sprot.Rotation = sprot.Rotation.identity()
    translation: np.ndarray = field(default_factory=lambda: np.zeros((3, 1)))

    def interp(self, other, ratio: float):
        """Linearly interpolate two poses."""
        ratio = np.clip(ratio, 0, 1)
        slerp = sprot.Slerp(
            [0.0, 1.0], sprot.Rotation.concatenate([self.rotation, other.rotation])
        )
        t_new = ratio * (other.translation - self.translation) + self.translation
        return Pose(rotation=slerp([ratio]), translation=t_new)

    def matrix(self):
        """Get homogeneous matrix."""
        T = np.eye(4)
        T[:3, :3] = self.rotation.as_matrix()
        T[:3, 3] = np.squeeze(self.translation)
        return T

    def compose(self, b_T_c):
        """Compose pose with other pose (i.e., a_T_b * b_T_c = a_T_c)."""
        a_T_c = self.matrix() @ b_T_c.matrix()
        t = a_T_c[:3, 3]
        q = sprot.Rotation.from_matrix(a_T_c[:3, :3])
        return Pose(rotation=q, translation=t)

    def export(self):
        """Export pose to json."""
        q = np.squeeze(self.rotation.as_quat()).tolist()
        t = np.squeeze(self.translation).tolist()
        return {
            "tx": t[0],
            "ty": t[1],
            "tz": t[2],
            "qx": q[0],
            "qy": q[1],
            "qz": q[2],
            "qw": q[3],
        }


def _interp_pose(stamp_ns, stamps, poses):
    left_idx = bisect.bisect_left(stamps, stamp_ns)
    if left_idx == len(stamps):
        return poses[-1]

    if stamps[left_idx] == stamp_ns:
        return poses[left_idx]

    prev_pose = poses[left_idx]
    prev_time = stamps[left_idx]
    curr_pose = poses[left_idx + 1]
    curr_time = stamps[left_idx + 1]
    ratio = (stamp_ns - prev_time) / (curr_time - prev_time)
    return Pose.interp(prev_pose, curr_pose, ratio)


def _overwrite_positions(point_path, map_path, order, G, align_submaps):
    map_path = _normalize_path(map_path)
    robot_name = map_path.stem.split(".")[0]  # drops the .sm
    robot_id = _get_index(order, robot_name)
    prefixes = [x.prefix for x in G.dynamic_layers if x.id == dsg.DsgLayers.AGENTS]
    layer = G.get_dynamic_layer(dsg.DsgLayers.AGENTS, prefixes[robot_id])
    stamps = []
    poses = []
    for node in layer.nodes:
        stamps.append(node.timestamp)
        q = node.attributes.world_R_body
        poses.append(
            Pose(
                sprot.Rotation.from_quat([q.x, q.y, q.z, q.w]), node.attributes.position
            )
        )

    with map_path.open("r") as fin:
        contents = json.load(fin)

    with point_path.open("r") as fin:
        points = json.load(fin)

    for idx, point in enumerate(points["points"]):
        contents["segments"][idx]["centroid_odom"] = point["pos"]

    if align_submaps:
        for submap in contents["submaps"]:
            stamp_ns = int(submap["seconds"] * 1.0e9) + int(submap["nanoseconds"])
            submap_pose = _interp_pose(stamp_ns, stamps, poses)
            submap["T_odom_submap"] = submap_pose.export()

    with map_path.open("w") as fout:
        json.dump(contents, fout)


def deform_maps(output, order, align_submaps):
    """Deform segment maps."""
    maps = [x for x in _normalize_path(output / "lcd").glob("*.sm.json")]

    map_dir = output / "robot_maps"
    map_dir.mkdir(exist_ok=True)

    point_dir = output / "points"
    point_dir.mkdir(exist_ok=True)

    point_paths = []
    for map_path in maps:
        point_paths.append(_save_map(map_path, order, point_dir))
        shutil.copy(map_path, map_dir / map_path.name)

    dgraph_path = output / "pgmo" / "deformation_graph.dgrf"
    command = ["hydra_multi_deform_map", dgraph_path] + point_paths
    ret = subprocess.run(command)
    if ret.returncode != 0:
        click.secho("[ERROR] Deformation graph failed!")

    fused_graph = dsg.DynamicSceneGraph.load(output / "dsg.json")
    for point_path in point_paths:
        _overwrite_positions(
            point_path,
            map_dir / point_path.name,
            order,
            fused_graph,
            align_submaps,
        )

    return map_dir


def roman_map_version_convert(filepath: pathlib.Path):
    """Convert ROMAN map versions."""
    from roman.utils import rotation_rm_roll_pitch

    with filepath.open("r") as f:
        roman_map = json.load(f)

    for seg in roman_map["segments"]:
        seg["robot_id"] = 0
        seg["stamp_last_seen"] = int(
            seg["last_seen"]["seconds"] * 1e9 + seg["last_seen"]["nanoseconds"]
        )
        seg["centroid_odom"] = {
            "x": seg["centroid_odom"][0],
            "y": seg["centroid_odom"][1],
            "z": seg["centroid_odom"][2],
        }
        # del seg['robot_name']
        # del seg['first_seen']
        # del seg['last_seen']

    for sm in roman_map["submaps"]:
        sm["robot_id"] = 0
        sm["stamp"] = int(sm["seconds"] * 1e9 + sm["nanoseconds"])
        sm["traversed_distance"] = 10.0

        # Expects T_odom_submap in robot frame (FLU)
        # TODO: not handling calibration right now, just estimating a rotation in place
        q = sprot.Rotation.from_quat(
            [
                sm["T_odom_submap"]["qx"],
                sm["T_odom_submap"]["qy"],
                sm["T_odom_submap"]["qz"],
                sm["T_odom_submap"]["qw"],
            ]
        )
        q_gravity_aligned = sprot.Rotation.from_matrix(
            rotation_rm_roll_pitch(q.as_matrix())
        )
        # q_FLU = sprot.Rotation.from_matrix(q_RDF.as_matrix() @ T_RDFFLU[:3,:3])
        sm["T_odom_submap"]["qx"] = q_gravity_aligned.as_quat()[0]
        sm["T_odom_submap"]["qy"] = q_gravity_aligned.as_quat()[1]
        sm["T_odom_submap"]["qz"] = q_gravity_aligned.as_quat()[2]
        sm["T_odom_submap"]["qw"] = q_gravity_aligned.as_quat()[3]
        # del sm['robot_name']

    with filepath.open("w") as f:
        json.dump(roman_map, f, indent=4)


def collate_maps(map_dir, output):
    """Combine segment maps into single unified map."""
    map_files = [x for x in map_dir.glob("*.json")]

    original_maps = []
    for map_file in map_files:
        with map_file.open("r") as fin:
            contents = json.load(fin)

        num_submaps = len(contents["submaps"])
        num_segments = len(contents["segments"])
        click.secho(
            f"Loaded {num_submaps} submaps and {num_segments} segments from {map_file}",
            fg="green",
        )

        original_maps.append(contents)

    first = True
    full_map = {"segments": [], "submaps": []}
    for prev_map in original_maps:
        if first:
            first = False
            segment_offset = 0
            submap_offset = 0
        else:
            segment_indices = [x["segment_index"] for x in full_map["segments"]]
            submap_indices = [x["submap_index"] for x in full_map["submaps"]]
            segment_offset = max(segment_indices) + 1
            submap_offset = max(submap_indices) + 1

        for segment in prev_map["segments"]:
            new_segment = copy.deepcopy(segment)
            new_segment["segment_index"] += segment_offset
            full_map["segments"].append(new_segment)

        for submap in prev_map["submaps"]:
            new_submap = copy.deepcopy(submap)
            new_submap["submap_index"] += submap_offset
            if "segment_indices" in new_submap:
                new_submap["segment_indices"] = [
                    x + segment_offset for x in new_submap["segment_indices"]
                ]
            full_map["submaps"].append(new_submap)

    map_path = output / "segment_map.json"
    with map_path.open("w") as fout:
        json.dump(full_map, fout, indent=2)


@click.command()
@click.argument("robot_directories", nargs=-1, type=click.Path(exists=True))
@click.option("-o", "--output", default=None, type=click.Path(), help="output file")
@click.option("-r", "--remap", multiple=True, type=str, help="robot name remap")
@click.option("-c", "--clean", is_flag=True, help="remove previous output if it exists")
@click.option("-f", "--force", is_flag=True, help="proceed without prompting")
@click.option("-v", "--verbosity", type=int, default=0, help="glog verbosity")
@click.option(
    "-m", "--submap-max-size", type=int, default=40, help="roman submap max size"
)
@click.option(
    "-t",
    "--lc-association-threshold",
    type=int,
    default=4,
    help="roman loop closure association threshold",
)
@click.option(
    "--config", default=None, type=click.Path(exists=True), help="config path"
)
@click.option(
    "--align-submaps/--no-align-submaps", default=True, help="interp submap poses"
)
@click.option(
    "--body-frame/--no-body-frame", default=True, help="loop closures in body frame"
)
@click.option("--gnc-alpha", default=None, type=float, help="gnc alpha to use")
def main(
    robot_directories,
    output,
    remap,
    clean,
    force,
    verbosity,
    submap_max_size,
    lc_association_threshold,
    config,
    align_submaps,
    body_frame,
    gnc_alpha,
):
    """Run intermission code."""
    # TODO(nathan) fix output path
    output = _normalize_path("fused") if output is None else _normalize_path(output)
    click.secho(f"Writing results to {output}!", fg="green")
    if output.exists():
        if clean:
            if not force:
                click.confirm(f"clean existing {output}?", abort=True, default=False)

            shutil.rmtree(output)
        else:
            click.secho(f"[WARNING] {output} exists already!", fg="yellow")
            if not force:
                click.confirm("continue?", abort=True, default=False)

    robot_directories = [_normalize_path(x) for x in robot_directories]
    output.mkdir(parents=True, exist_ok=True)
    lcd(
        robot_directories,
        output,
        submap_max_size=submap_max_size,
        lc_association_thresh=lc_association_threshold,
    )

    remaps = [x.split(":")[:2] for x in remap]
    remaps = {k: v for k, v in remaps}
    click.secho(f"Using remaps: {remaps}", fg="green")
    order = [_normalize_path(x).stem for x in robot_directories]
    click.secho(f"Robot order: {order}", fg="green")
    lcd_file = collate_loopclosures(output, order, remaps, body_frame)

    if config is None:
        config = _default_config()
        click.secho(f"[WARNING] Using default config {config}", fg="yellow")

    config = _normalize_path(config)
    command = [
        "offline_fusion",
        "--config",
        config,
        f"-v={verbosity}",
        "--output",
        str(output),
        "--loopclosures",
        str(lcd_file),
    ] + [str(_normalize_path(x)) for x in robot_directories]
    if gnc_alpha is not None:
        command += ["--gnc_alpha", str(gnc_alpha)]

    ret = subprocess.run(command)
    if ret.returncode != 0:
        click.secho("[ERROR] Fusion failed!", fg="red")

    map_dir = deform_maps(output, order, align_submaps)
    collate_maps(map_dir, output)

    roman_map_version_convert(output / "segment_map.json")


if __name__ == "__main__":
    main()
